#+title:第十一章 认识与学习 BASH
#+author: lemon
#+date:<2016-03-21 Mon>


* 认识 BASH 这个 Shell

实际上，管理计算机硬件的其实是操作系统的核心(kernel),所以用户是通过 shell 来跟核心沟通，来完成工作。

** 硬件、核心、Shell

Shell 其实就是一组接口，用户通过这些接口来操作系统的应用程序来完成自己的工作。本文所涉及的 shell 主要是指命令方面的东西，例如 BASH。
我们必须要通过 shell 来将我们输入的命令与 Kernel交互，让 Kernel 来控制硬件来完成工作。

** 学 shell 的理由

+ 各个不同的 unix like 系统的 shell 都相差不远，但是各个系统的图形界面就不一样。
+ 远程管理中，命令行接口速度更快

** 系统的合法 shell 与 /etc/shells 功能

shell 的版本有很多，一种比较出名的 shell 称之为 bash，下面列出 linux 系统上常见的 shell,这些可以的 shell 都
写在 /etc/shells 这个文件里面：

| 名称      | 备注                                             |
|-----------+--------------------------------------------------|
| /bin/sh   | 已经被 bash 所取代                               |
| /bin/bash | 就是 Linux 默认的 shell                          |
| /bin/ksh  | Kornshell 由 AT&T Bell lab 发展出来，兼容于 bash |
| /bin/tcsh | 整合 c Shell                                     |
| /bin/csh  | 已经被 /bin/tcsh 所取代                          |
| /bin/zsh  | 基于 ksh 发展出来的，功能更加强大的 shell                       |

只有在这个文件中的 shell 才会被认为是合法的 shell。


** Bash shell 的功能

/bin/shell 是 linux 默认的 shell， 能够作为默认的 shell， bash 肯定有很多的优点，主要是如下的优点:


+ 命令记忆功能(history)
  在命令行中，只要通过上下键就可以找到前后使用过的命令。这些命令记录在 .bash_history 文件中，.bash_history 记录的
  是上一次登录所运行过的命令。当起登录所使用的命令都在内存中，在系统成功注销之后，这些用过的命令才会被写入到 .bash_history中。
+ 命令与文件补全功能(tab键)
+ 命令别名配置功能

  #+BEGIN_SRC shell
    alias lm = 'ls -al'
  #+END_SRC
+ 工作控制、前景背景控制
+ 程序化脚本（shell script）
+ 通配符
  #+BEGIN_SRC shell
    ls -l /usr/bin/X*
  #+END_SRC

** Bash shell 的内建命令: type 查询

通过 type 命令可以查询一个命令是来自于外部的命令还是内建在 bash 中。


#+BEGIN_SRC shell
  type [-tpa] name
#+END_SRC

| 参数 | 备注                                                                  |
|------+-----------------------------------------------------------------------|
|      | 不加任何选项和参数时，type 会显示 name 是外部命令还是 bash 的内建命令 |
| -t   | 当加入 -t 参数时，type 会将 name 以底下的这些字眼显示出他的意义       |
| -p   | 如果后面接的 name 为外部命令时，才会显示完整的文件名                  |
| -a   | 会由 PATH 变量定义的路径中，将所有含 name 的命令都列出来，包含 alias                           |

** 命令下达
命令太长太长可以使用 \Enter 将命令分成两行来输入:

#+BEGIN_SRC shell
   cp /var/spool/mail/root /etc/crontab \
   > /etc/fstab/root
#+END_SRC

* Shell 的变量功能

shell 中的变量支持着整个 linux 的正常运作，例如多用户的划分等，这些都离不开变量的支持。

** 变量

+ 变量的可变性与方便性
+ 影响 bash 环境操作的变量
  环境变量一般是大写，与普通的自定义变量分开。
+ 脚本程序的好帮手

** 变量的取用与配置：echo，变量配置方法，unset

+ 变量的取用 echo
+ 变量的配置方法
  - 变量与变量的内容用 = 来连接
    #+BEGIN_SRC shell
       myname=lemon
    #+END_SRC
  - 等号两边不能有空格
  - 变量的名称只能是英文字母与数字，但是不能以数字开头
  - 变量内容若有空格符可以用单引号或者双引号连接起来，双引号连接的字符串里面可以有变量，单引号连接的只能有纯字符串
    #+BEGIN_SRC shell
       var="lang is $LANG" => lang is US
       var='lang is $LANG' => lang is $LANG
    #+END_SRC
  - 可以使用转义字符将特殊符号转化成普通的符号
  - 如该变量为扩增变量内容时，可以使用以下方法来扩充:
    #+BEGIN_SRC shell
      PATH = "$PATH":/home/bin
    #+END_SRC
  - 若该变量需要在其他的程序上使用，则使用 export 来使变量变成环境变量
  - 通常大写变量为系统默认变量，自行配置变量可以使用小写字符
  - 取消变量方法为使用 unset:
    #+BEGIN_SRC shell
      unset myname
    #+END_SRC

** 环境变量的功能

+ 用 env 观察环境变量与常见环境变量说明
+ 用 set 观察所有变量（含环境变量与自定义变量）
  基本上，在 linux 默认情况中，使用大写字母来配置的变量一般为系统内定需要的变量
+ export 自定义变量转成环境变量
  子程序会继承父程序的环境变量，子程序不会集成父程序的自定义变量

** 影响显示结果的语系变量（locale）

   locale 中的所有语系变量我们都可以修改，但是如果你配置了 LANG 或者 LC_ALL 时，其他的语系变量就
会被这两个变量所替代。

** 变量的有效范围
   通俗来说，全局变量就相当于 linux 系统中的环境变量，局部变量就相遇 linux 系统中的自定义变量。在 linux
中，是通过以下的方法来做到环境变量的共享:

   + 当启动一个 shell，操作系统会分配一块内存给 shell 使用，这个内存内的变量可以和子程序共享
   + 父程序使用 export 命令，可以将自定义的变量写入到这块内存中
   + 当另一个子程序启动后，也可以使用内存中的环境变量

** 变量键盘读取、数组与宣告： read, array, declare

+ 要读取来自键盘的变量，就是使用 read 这个命令
+ declare /typeset 两个命令的功能是一样的，就是在声明变量的类型。
  - 变量类型默认为字符串，如果不指定类型，则 1+2 表示的是字符串而不是计算式
  - bash 环境中的数值运算，默认仅能达到整数形态，例如 1/3 的结果是 0

  | 参数 | 备注                                   |
  |------+----------------------------------------|
  | -a   | 将变量定义成数组（array）类型          |
  | -i   | 将变量定义成整数类型                   |
  | -x   | 与 export 功能一样，将变量变成环境变量 |
  | -r   | 将变量配置成为 readonly 类型，该变量不能被更改内容，也不能 unset |
+ 数组变量类型

** 与文件系统及程序的限制关系：ulimit
   bash 可以限制用户的某些系统资源，包括开启文件的数量，cpu 的使用时间，可以使用的内存总量等。

** 变量内容的删除、取代与替换


+ 变量内容的删除与取代
+ 变量的测试与内容替换

* 命令别名和历史命令

在命令行环境下工作时，有时候输入的命令的长度会很长。如果每次都需要手动去输入这些命令，不仅耗时而且很容易出现误操作。使用历史命令的功能的话
必须需要近期使用过这个命令。那么这个时候别名这个功能就很有用了。

#+BEGIN_SRC shell
   alias lm='ls -al|more'
#+END_SRC

以上大概就是别名的功能，就是定义一个更短的命令来替代很长的命令，既简介又高效，而且不容易出错。

alias 的定义方法与变量定义的方法几乎相同。



可以通过 history 这个命令来查询之前使用过的命令。

| 参数 | 备注                                                                                        |
|------+---------------------------------------------------------------------------------------------|
| n    | 数字，列出最近使用的 n 行命令 的意思                                                        |
| -c   | 将目前 shell 中所有的 history 的内容全部消除                                                |
| -a   | 将目前新增的 history 命令新增入 histfiles 中，若没有加 histfiles, 则默认写入 ~/bash_history |
| -r   | 将 histfiles 的内容读取到目前这个 shell 的 history 记忆中                                   |
| -w   | 将目前的 history 内存的内容写入到 histfiles 中                                                           |


~/.bash_history 中能够存储命令的条数与 HISTFILESIZE 有关。

* Bash shell 的操作环境

在我们登录上 Linux 系统之后，系统会帮我配置好一些环境，我们也可以通过设置，让系统绑我们主动配置好我们喜欢的操作环境。


** 路径与命令搜寻顺序

在 linux 中，命令运行的顺序大概是下面这样的：

+ 以相对/绝对路径运行命令，例如 /bin/ls 或者 ./ls
+ 由 alias 找到该命令来运行
+ 由 bash 内建的命令来运行
+ 通过 $PATH 这个变量的顺序寻找到的第一个命令来执行

** bash 的进站与欢迎信息 /etc/issue, /etc/motd

/etc/issue 是本机登录时使用的，
/etc/issue.net 是提供给远程登录时使用的

如果想让使用者登录后取得一些信息，可以将这些信息加入 /etc/motd 里面去。


** bash 的环境配置文件

在进入系统的时候，bash 会自动的去读取这些配置文件，才给了我们的工作环境，这些配置文件又分为整个系统的配置文件和个人的偏好的配置文件，
在做了一些自定义的配置后，如果要想保留这些配置，就要将这些配置写入到配置文件中才行。


*** login 与 non-login shell

+ login shell
  取得 bash 时需要完整的登录流程，就称之为 login shell。举例来说，你要由 tty1-tty6 登录，需要输入用户的帐号与密码，此时取得的
bash 就称之为 login shell

+ non-login shell
  取得 bash 接口的方法不需要重复的登录。例如：1、你使用 x window 登录 linux 之后，再在系统内启动终端，此时的这个终端并不需要
帐号和密码，那么这个环境就称之为 non-login shell 2、在原本的 bash 环境下再次下达 bash 这个命令之后，同样也不需要帐号和密码
这个也是 non-login shell


login shell 会读取以下的两个配置文件:

+ /etc/profile 系统配置

+ ~/.bash_profile 或者 ~/.bash_login 或者 ~/.profile： 这些属于个人配置，如果需要修改数据，直接修改这里



+ /etc/profile(login shell 才会读)
  每个配置文件可以利用用户的 UID 来决定很多重要的数据，每个用户在登录取得 bash 时一定会读取这个配置文件。
  这里文件里面主要的配置有：
  - PATH 会根据 UID 决定 PATH 变量要不要含有 sbin 的系统命令目录
  - MAIL 依据帐号配置好用户的 mailbox 到 /var/spool/mail 帐号名
  - USER 依据用户的帐号配置这个变量的内容
  - HOSTNAME 依据主机的 hostname 命令决定这个变量的内容
  - HISTSIZE 历史命令的记录条数

  /etc/profile 除了有这些变量外，还会去读取其他的配置文件，主要是以下的配置文件:
  - /etc/inputrc

  - /etc/profile.d/*.h

  - /etc/sysconfig/i18n


+ ~/.bash_profile(login 才会读)

在读取完系统的配置文件之后，接下来就会读取个人的配置文件，按照以下的顺序:

   + ~/.bash_profile
   + ~/.bash_login
   + ~/.profile

实际上， bash shell 只会读取上面三个文件中的一个，读取顺序是依照上面的顺序。


+ source  读入环境变量配置的文件

+ ~/.bashrc (non login shell会读)


+ 其他相关配置文件

  - /etc/man.config
    这个文件里面规范了使用 man 的时候，man page 的路径

  - ~/.bash_history

  - ~/.bash_logout

** 终端机的环境配置：stty， set

** 通配符与特殊符号


| 符号 | 含义                                                                                |
|------+-------------------------------------------------------------------------------------|
| *    | 代表 0 到无穷个任意字符                                                             |
| ？   | 代表一定有一个任意字符                                                              |
| []   | 代表一定有一个在括号内的字符, 例如[abcd]代表一定有一个字符，可能是 a,b,c,d 中的一个 |
| [-]  | 代表在编码顺序内的所有字符，例如[0-9]代表0到9之间的所有数字                         |
| [^]  | 若中括号内的第一个字符为 ^,则代表反向选择，例如 [^abc] 代表一个除了 a,b,c 以外的其他字符                                |
* 数据流重定向
  数据流重定向大致就是将某个命令运行后要出现在屏幕上的数据传输到其他的地方。

** 什么是数据流重定向


*** standard output 与 standard error output

  + standard output 命令运行所回传的正确的信息
  + standard error output 命令运行失败后所回传的错误信息

数据重定向将 standard output 与 standard error output 分别传送到其他的文件中去，


| 输入   | 代码 | 符号      |
|--------+------+-----------|
| stdin  |    0 | < 或者 << |
| stdout |    1 | > 或 >>   |
| stderr |    2 | 2> 或者 2>> |


*** /dev/null 存储错误信息

    可以将错误信息通过数据流重定向的方法输入到 /dev/null 中。

*** standard input: < 与 <<

将原本需要由键盘输入的数据改由文件内容来替代。

** 命令运行的判断工具: ; && ||

*** cmd ;

在命令与命令中间利用 ； 来隔开，这样一来，分号前面的命令运行完后就会接着运行后面的命令了。

*** $?(命令回传值) 与 $$ 或者 ||

两个命令的相依性主要判断的地方在于前一个命令运行的运行结果是否正确。

| 命令         | 备注                                                                                     |
|--------------+------------------------------------------------------------------------------------------|
| cmd1 && cmd2 | 若 cmd1 运行完毕且运行结果正确，则开始运行 cmd2，若 cmd1 的运行结果不正确，则不运行 cmd2 |
| cmd1 || cmd2   | 若 cmd1 运行完毕且运行结果正确，则 cmd2 不运行， 若cmd1 的运行结果不正确，则运行 cmd2    |
* 管道命令

管道命令由 | 来表示， 管道命令与连续下达命令是不一样的。管道命令 | 仅能处理由前一个命令传来的正确信息，也就是 standard output 信息，
对于 standard error 信息没有直接的处理的能力。

注：
+ 管道命令仅会处理 standard ouput，对于 standard error output 会予以忽略
+ 管道命令必须要能够接收来自前一个命令的数据成为 standard input 继续处理才行


** 截取命令：cut grep

cut 是将一段 信息的某一段切出来，是以行为单位来切割的。

grep 是将满足我们要求的那一行数据给提取出来。

** 排序命令 sort wc uniq

+ sort 可以帮助排序，对于不同的数据形态来进行排序

 | 参数 | 备注                                    |
 |------+-----------------------------------------|
 | -f   | 忽略大小写的差异                        |
 | -b   | 忽略最前面的空格                        |
 | -M   | 以月份的名字来排序                      |
 | -n   | 使用纯数字来进行排序                    |
 | -r   | 反向排序                                |
 | -u   | 就是 uniq，相同的数据中，仅出现一行代表 |
 | -t   | 分隔符，默认使用 tab 键来分隔           |
 | -k   | 以一个区间来进行排序                              |

+ uniq  排序完成之后，将重复的数据仅列出一个显示

 | 参数 | 意义                 |
 |------+----------------------|
 | -i   | 忽略大小写字符的不同 |
 | -c   | 进行计数                 |

+ wc 计算出文件中的行数，字数，字符数

  | 参数 | 备注       |
  |------+------------|
  | -l   | 仅列出行   |
  | -w   | 仅列出字数 |
  | -m   | 多少字符       |

** 双向重导向 tee

tee 可以让 standard ouput 转存一份到文件内，并将同样的数据送到屏幕。



** 字符转换命令 tr col join paste expand

+ tr 可以用来删除一段信息当中的文字，或者是进行文字信息的替换
  | 参数 | 备注                  |
  |------+-----------------------|
  | -d   | 删除信息中 耨个字符串 |
  | -s   | 取代重复的字符               |

+ col 用来将 tab 安装键取代为空格键，常用于将 man page 转存为纯文本以方便查阅的功能
  | 参数 | 备注                        |
  |------+-----------------------------|
  | -x   | 将 tab 键转换成对等的空格键 |
  | -b   | 在文字内有反斜杠 / 时，仅保留反斜杠最后接的那个字符 |


+ join 两个文件当中，有相同数据的那一行，才将他们加在一起

  | 参数 | 意义                                                                                                                |
  |------+---------------------------------------------------------------------------------------------------------------------|
  | -t   | join 默认以空格符分隔数据，并且比对第一个字段的数据，如果两个文件相同，则将两笔数据联成一行，且第一个字段放在第一个 |
  | -i   | 忽略大小写的差异                                                                                                    |
  | -1   | 这个是数字 1， 代表第一个文件要用那个字段来分析的意思                                                               |
  | -2   | 代表第二个文件要用那个字段来分析的意义                                                                                                 |

  注： 在使用 join 之前，你所需要处理的文件应该事先经过排序处理

+ paste 将两个文件的两行贴在一起，而且中间使用 tab 键隔开

+ expand 这个命令将 tab 按键转成空格键


** 分割命令 split

这个命令可以帮助你将一个大文件，根据文件大小或者行数来进行分隔，这样就可以将大文件分隔成小文件。

| 参数   | 备注                                        |
|--------+---------------------------------------------|
| -b     | 后面可接分隔成的文件大小，可加单位 b,k,m 等 |
| -l     | 以行数来进行分割                            |
| PREFIX | 代表前导符的意思，可以作为分隔文件的前导文字                      |

** 参数替换 xargs

   以空格符作为分隔，读入 stdin 的数据，将 stdin 的数据分隔成 arguments
   | 参数 | 备注                                                                                   |
   |------+----------------------------------------------------------------------------------------|
   | -0   | 如果输入的 stdin 含有特殊字符，这个 -0 可以将它还原成一般字符                          |
   | -e   | 这个参数是 eof 的意思，后面可以接一个字符串，档 xargs 分析到这个字符串时，就会停止工作 |
   | -p   | 在运行每个命令的 argument 时，都会询问使用者的意思                                     |
   | -n   | 后面接次数，每次 command 命令运行时，要使用几个参数的意思                                                      |

** 关于 - 号的用途

  '-' 可以用来替代 stdin 与 stdout 来替代。
